# -*- coding: utf-8 -*-
"""
AreaLoad - Professional area load object for surface loading

This module provides comprehensive area loading capabilities for structural surfaces
including pressure loads, distributed loads, wind loads, and thermal effects.
"""

import FreeCAD as App
import FreeCADGui as Gui
import Part
import Draft
import math
import numpy as np
from typing import List, Dict, Tuple, Optional, Any
try:
    from PySide2 import QtCore, QtWidgets, QtGui
except ImportError:
    try:
        from PySide import QtCore, QtGui
        QtWidgets = QtGui
    except ImportError:
        QtCore = QtWidgets = QtGui = None
import os
import math
import FreeCAD as App
import Part

class AreaLoad:
    """
    Professional area load object for structural surfaces.
    
    Provides comprehensive area loading capabilities including:
    - Pressure loads (uniform, linear, point)
    - Building code loads (dead, live, wind, seismic)
    - Load patterns and distributions
    - Load combinations integration
    """
    
    def __init__(self, obj):
        """
        Initialize AreaLoad object.
        
        Args:
            obj: FreeCAD DocumentObject to be enhanced
        """
        self.Type = "AreaLoad"
        obj.Proxy = self
        
        # Ensure we're starting with a clean object
        self._ensure_property_exists = self._create_property_adder(obj)
        
        # Target geometry
        obj.addProperty("App::PropertyLinkList", "TargetFaces", "Geometry",
                       "Faces or surfaces to apply load")
        
        obj.addProperty("App::PropertyArea", "LoadedArea", "Geometry",
                       "Total loaded area (calculated)")
        
        obj.addProperty("App::PropertyVector", "LoadDirection", "Geometry",
                       "Load direction vector (global coordinates)")
        obj.LoadDirection = App.Vector(0, 0, -1)  # Downward default
        
        obj.addProperty("App::PropertyEnumeration", "Direction", "Geometry",
                       "Load direction")
        obj.Direction = ["+X Global", "-X Global", "+Y Global", "-Y Global", "+Z Global", "-Z Global", "Normal", "Custom"]
        obj.Direction = "-Z Global"  # Downward default
        
        obj.addProperty("App::PropertyVector", "CustomDirection", "Geometry",
                       "Custom load direction vector")
        obj.CustomDirection = App.Vector(0, 0, -1)  # Downward default
        
        # Load definition
        obj.addProperty("App::PropertyEnumeration", "LoadType", "Load",
                       "Type of area load")
        obj.LoadType = [
            "Dead Load (DL)", "Live Load (LL)", "Live Load Roof (LL_Roof)",
            "Wind Load (W)", "Earthquake (E)", "Earth Pressure (H)",
            "Fluid Pressure (F)", "Thermal (T)", "Custom Pressure"
        ]
        obj.LoadType = "Dead Load (DL)"
        
        obj.addProperty("App::PropertyEnumeration", "LoadCategory", "Load",
                       "Load category for combinations")
        obj.LoadCategory = ["DL", "LL", "LL_Roof", "W", "E", "H", "F", "T", "CUSTOM"]
        obj.LoadCategory = "DL"
        
        # Load intensity and distribution
        obj.addProperty("App::PropertyPressure", "LoadIntensity", "Load",
                       "Load intensity (pressure)")
        obj.LoadIntensity = "2.4 kN/m^2"  # Typical dead load
        
        obj.addProperty("App::PropertyEnumeration", "Distribution", "Load",
                       "Load distribution type")
        obj.Distribution = ["Uniform", "Linear X", "Linear Y", "Parabolic", "Point Load"]
        obj.Distribution = "Uniform"
        
        obj.addProperty("App::PropertyFloatList", "DistributionParameters", "Load",
                       "Parameters for load distribution")
        obj.DistributionParameters = [1.0]  # Default uniform distribution
        
        obj.addProperty("App::PropertyEnumeration", "DistributionPattern", "Load",
                       "Load distribution pattern")
        obj.DistributionPattern = [
            "Uniform", "Linear X", "Linear Y", "Bilinear", "Radial", 
            "Point Load", "Line Load", "Custom Pattern"
        ]
        obj.DistributionPattern = "Uniform"
        
        obj.addProperty("App::PropertyFloatList", "DistributionFactors", "Load",
                       "Distribution factors for non-uniform patterns")
        obj.DistributionFactors = [1.0, 1.0, 1.0, 1.0]  # Corner factors
        
        # Load distribution method (based on RISA documentation)
        obj.addProperty("App::PropertyEnumeration", "LoadDistribution", "Distribution",
                       "Method for distributing load to supporting elements")
        obj.LoadDistribution = ["OneWay", "TwoWay", "OpenStructure"]
        obj.LoadDistribution = "TwoWay"  # Default to two-way distribution
        
        # Direction specification for one-way loads
        obj.addProperty("App::PropertyEnumeration", "OneWayDirection", "Distribution",
                       "Direction for one-way load distribution")
        obj.OneWayDirection = ["X", "Y", "Custom"]
        obj.OneWayDirection = "X"
        
        obj.addProperty("App::PropertyVector", "CustomDistributionDirection", "Distribution",
                       "Custom direction vector for one-way distribution")
        obj.CustomDistributionDirection = App.Vector(1, 0, 0)  # X-direction default
        
        # Edge-specific load distribution factors
        obj.addProperty("App::PropertyFloatList", "EdgeDistributionFactors", "Distribution",
                       "Distribution factors for load attribution to edges")
        obj.EdgeDistributionFactors = [1.0, 1.0, 1.0, 1.0]  # Default equal distribution
        
        # Load case properties
        obj.addProperty("App::PropertyString", "LoadCase", "Case",
                       "Load case identifier")
        obj.LoadCase = "DL1"
        
        obj.addProperty("App::PropertyString", "LoadCombination", "Case",
                       "Load combination identifier")
        
        obj.addProperty("App::PropertyFloat", "LoadFactor", "Case",
                       "Load factor for combinations")
        obj.LoadFactor = 1.0
        
        # Time-dependent properties
        obj.addProperty("App::PropertyBool", "IsTimeDependent", "Time",
                       "Time-dependent load")
        obj.IsTimeDependent = False
        
        obj.addProperty("App::PropertyPythonObject", "TimeFunction", "Time",
                       "Time variation function")
        
        # Building code specific properties
        obj.addProperty("App::PropertyEnumeration", "BuildingCode", "Code",
                       "Building code standard")
        obj.BuildingCode = [
            "ASCE 7-16", "IBC 2018", "NBCC 2015", "Eurocode 1", 
            "AS/NZS 1170", "Custom"
        ]
        obj.BuildingCode = "ASCE 7-16"
        
        obj.addProperty("App::PropertyString", "OccupancyType", "Code",
                       "Building occupancy type")
        obj.OccupancyType = "Office"
        
        obj.addProperty("App::PropertyFloat", "ImportanceFactor", "Code",
                       "Importance factor for design")
        obj.ImportanceFactor = 1.0
        
        # Load reduction and modification
        obj.addProperty("App::PropertyBool", "ApplyLoadReduction", "Reduction",
                       "Apply live load reduction")
        obj.ApplyLoadReduction = True
        
        obj.addProperty("App::PropertyFloat", "ReductionFactor", "Reduction",
                       "Live load reduction factor")
        obj.ReductionFactor = 1.0
        
        obj.addProperty("App::PropertyFloat", "TributaryArea", "Reduction",
                       "Tributary area for load reduction")
        
        # Environmental loads
        obj.addProperty("App::PropertyFloat", "WindSpeed", "Environmental",
                       "Basic wind speed (m/s)")
        obj.WindSpeed = 50.0
        
        obj.addProperty("App::PropertyEnumeration", "ExposureCategory", "Environmental",
                       "Wind exposure category")
        obj.ExposureCategory = ["A", "B", "C", "D"]
        obj.ExposureCategory = "B"
        
        obj.addProperty("App::PropertyFloat", "SeismicAcceleration", "Environmental",
                       "Peak ground acceleration for seismic")
        obj.SeismicAcceleration = 0.2
        
        # Thai Units Support
        obj.addProperty("App::PropertyBool", "UseThaiUnits", "Thai Units",
                       "Enable Thai units for load calculations")
        obj.UseThaiUnits = False
        
        obj.addProperty("App::PropertyPressure", "LoadIntensityKsc", "Thai Units", 
                       "Load intensity in ksc/m² (Thai units)")
        obj.LoadIntensityKsc = "240 kgf/cm^2/m^2"  # Equivalent to 2.4 kN/m²
        
        obj.addProperty("App::PropertyPressure", "LoadIntensityTfM2", "Thai Units",
                       "Load intensity in tf/m² (Thai units)")
        obj.LoadIntensityTfM2 = "0.24 tf/m^2"
        
        obj.addProperty("App::PropertyFloat", "LoadFactorThai", "Thai Units",
                       "Load factor per Thai Ministry B.E. 2566")
        obj.LoadFactorThai = 1.4
        
        obj.addProperty("App::PropertyFloat", "TemperatureChange", "Environmental",
                       "Temperature change (°C)")
        obj.TemperatureChange = 0.0
        
        # Load application properties
        obj.addProperty("App::PropertyVector", "ReferencePoint", "Application",
                       "Reference point for load application")
        
        obj.addProperty("App::PropertyVector", "LoadCenter", "Application",
                       "Center point of the load application")
        obj.LoadCenter = App.Vector(0, 0, 0)
        
        # Results and integration
        obj.addProperty("App::PropertyBool", "ProjectToSurface", "Application",
                       "Project load normal to surface")
        obj.ProjectToSurface = True
        
        obj.addProperty("App::PropertyFloat", "LoadEccentricity", "Application",
                       "Load eccentricity from surface centroid")
        obj.LoadEccentricity = 0.0
        
        obj.addProperty("App::PropertyForce", "TotalLoad", "Results",
                       "Total applied load")
        obj.TotalLoad = 0.0
        
        obj.addProperty("App::PropertyVector", "LoadResultant", "Results",
                       "Resultant load vector")
        obj.LoadResultant = App.Vector(0, 0, 0)
        
        obj.addProperty("App::PropertyBool", "IsValid", "Validation",
                       "Whether the load definition is valid")
        obj.IsValid = True
        
        # Visualization properties
        obj.addProperty("App::PropertyBool", "ShowLoadArrows", "Display",
                       "Show load arrows")
        obj.ShowLoadArrows = True
        
        obj.addProperty("App::PropertyFloat", "ArrowScale", "Display",
                       "Scale factor for load arrows")
        obj.ArrowScale = 1.0
        
        obj.addProperty("App::PropertyInteger", "ArrowDensity", "Display",
                       "Density of load arrows")
        obj.ArrowDensity = 5
        
        obj.addProperty("App::PropertyColor", "LoadColor", "Display",
                       "Color for load display")
        obj.LoadColor = (1.0, 0.0, 0.0)  # Red
        
        obj.addProperty("App::PropertyLinkList", "LoadVisualization", "Display",
                       "Visualization objects for the load")
        obj.LoadVisualization = []
        
        obj.addProperty("App::PropertyBool", "ShowLoadDistribution", "Display",
                       "Show load distribution pattern")
        obj.ShowLoadDistribution = True
        
        obj.addProperty("App::PropertyInteger", "DisplayDensity", "Display",
                       "Density of load visualization")
        obj.DisplayDensity = 10
        
        # Analysis properties
        obj.addProperty("App::PropertyBool", "IncludeInAnalysis", "Analysis",
                       "Include this load in structural analysis")
        obj.IncludeInAnalysis = True
        
        obj.addProperty("App::PropertyEnumeration", "LoadMethod", "Analysis",
                       "Method for load application in FEA")
        obj.LoadMethod = ["Nodal Forces", "Pressure", "Body Force"]
        obj.LoadMethod = "Pressure"
        
        obj.addProperty("App::PropertyForce", "Magnitude", "Load",
                       "Load magnitude")
        obj.Magnitude = "2.4 kN/m^2"  # Typical dead load
        
        obj.addProperty("App::PropertyInteger", "LoadSteps", "Analysis",
                       "Number of load steps for nonlinear analysis")
        obj.LoadSteps = 1
        
        # Initialize calculations
        self.calculateLoadProperties(obj)
    
    def getLoadInThaiUnits(self, obj):
        """Get load values in Thai units"""
        if not hasattr(obj, 'UseThaiUnits') or not obj.UseThaiUnits:
            return None
            
        try:
            # Import Thai units converter
            from ..utils.universal_thai_units import UniversalThaiUnits
            converter = UniversalThaiUnits()
            
            # Get load intensity in SI units
            intensity_kn_m2 = self.parseLoadIntensity(obj.LoadIntensity)
            
            # Convert to Thai units
            intensity_ksc = converter.kn_m2_to_ksc_m2(intensity_kn_m2)
            intensity_tf_m2 = converter.kn_m2_to_tf_m2(intensity_kn_m2)
            
            # Update Thai unit properties
            obj.LoadIntensityKsc = f"{intensity_ksc:.2f} kgf/cm^2/m^2"
            obj.LoadIntensityTfM2 = f"{intensity_tf_m2:.3f} tf/m^2"
            
            thai_results = {
                'intensity_ksc': intensity_ksc,
                'intensity_tf_m2': intensity_tf_m2,
                'total_force_kgf': converter.kn_to_kgf(obj.TotalForce) if hasattr(obj, 'TotalForce') else 0,
                'total_force_tf': converter.kn_to_tf(obj.TotalForce) if hasattr(obj, 'TotalForce') else 0,
                'area_m2': obj.LoadedArea if hasattr(obj, 'LoadedArea') else 0,
                'load_factor_thai': obj.LoadFactorThai if hasattr(obj, 'LoadFactorThai') else 1.4
            }
            
            return thai_results
            
        except Exception as e:
            App.Console.PrintError(f"Error converting to Thai units: {e}\n")
            return None
    
    def updateThaiUnits(self, obj):
        """Update Thai units when properties change"""
        if hasattr(obj, 'UseThaiUnits') and obj.UseThaiUnits:
            self.getLoadInThaiUnits(obj)
    
    def calculateLoadProperties(self, obj):
        """Calculate basic load properties."""
        try:
            if not obj.TargetFaces:
                return
                
            # Calculate total loaded area
            total_area = 0.0
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape') and hasattr(face_obj.Shape, 'Area'):
                    total_area += face_obj.Shape.Area
                    
            obj.LoadedArea = total_area
            
            # Calculate total force
            if hasattr(obj, 'LoadIntensity'):
                intensity = self.parseLoadIntensity(obj.LoadIntensity)
                obj.TotalForce = intensity * total_area
                
            # Calculate center of pressure
            self.calculateCenterOfPressure(obj)
            
            # Update Thai units if enabled
            if hasattr(obj, 'UseThaiUnits') and obj.UseThaiUnits:
                self.updateThaiUnits(obj)
            
        except Exception as e:
            App.Console.PrintError(f"Error calculating load properties: {e}\n")
    
    def calculateLoadProperties(self, obj):
        """Calculate basic load properties."""
        try:
            if not obj.TargetFaces:
                return
                
            # Calculate total loaded area
            total_area = 0.0
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape') and hasattr(face_obj.Shape, 'Area'):
                    total_area += face_obj.Shape.Area
                    
            obj.LoadedArea = total_area
            
            # Calculate total force
            if hasattr(obj, 'LoadIntensity'):
                intensity = self.parseLoadIntensity(obj.LoadIntensity)
                obj.TotalForce = intensity * total_area
                
            # Calculate center of pressure
            self.calculateCenterOfPressure(obj)
            
        except Exception as e:
            App.Console.PrintError(f"Error calculating load properties: {e}\n")
    
    def parseLoadIntensity(self, intensity_str):
        """Parse load intensity string to numerical value."""
        try:
            if isinstance(intensity_str, (int, float)):
                return float(intensity_str)
            
            # Handle unit strings like "2.4 kN/m^2"
            value_str = str(intensity_str).split()[0]
            return float(value_str)
        except:
            return 0.0
    
    def calculateCenterOfPressure(self, obj):
        """Calculate center of pressure for the load."""
        try:
            if not obj.TargetFaces:
                return
                
            total_area = 0.0
            weighted_center = App.Vector(0, 0, 0)
            
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape') and hasattr(face_obj.Shape, 'CenterOfMass'):
                    area = face_obj.Shape.Area
                    center = face_obj.Shape.CenterOfMass
                    
                    weighted_center = weighted_center + (center * area)
                    total_area += area
            
            if total_area > 0:
                obj.CenterOfPressure = weighted_center / total_area
                
        except Exception as e:
            App.Console.PrintError(f"Error calculating center of pressure: {e}\n")
    
    def applyBuildingCodeLoads(self, obj):
        """Apply building code specific loads."""
        try:
            code = obj.BuildingCode
            load_type = obj.LoadType
            occupancy = obj.OccupancyType
            
            if code == "ASCE 7-16":
                self.applyASCE7Loads(obj, load_type, occupancy)
            elif code == "IBC 2018":
                self.applyIBCLoads(obj, load_type, occupancy)
            elif code == "Eurocode 1":
                self.applyEurocodeLoads(obj, load_type, occupancy)
                
        except Exception as e:
            App.Console.PrintError(f"Error applying building code loads: {e}\n")
    
    def applyASCE7Loads(self, obj, load_type, occupancy):
        """Apply ASCE 7-16 loads."""
        if "Dead Load" in load_type:
            # Typical dead load values
            if "concrete" in occupancy.lower():
                obj.LoadIntensity = "3.6 kN/m^2"  # 75 psf
            else:
                obj.LoadIntensity = "2.4 kN/m^2"  # 50 psf typical
                
        elif "Live Load" in load_type:
            # ASCE 7 Table 4.3-1
            live_loads = {
                "office": "2.4 kN/m^2",     # 50 psf
                "residential": "1.9 kN/m^2", # 40 psf
                "retail": "4.8 kN/m^2",     # 100 psf
                "classroom": "1.9 kN/m^2",  # 40 psf
                "corridor": "3.8 kN/m^2"    # 80 psf
            }
            
            for key, value in live_loads.items():
                if key in occupancy.lower():
                    obj.LoadIntensity = value
                    break
            else:
                obj.LoadIntensity = "2.4 kN/m^2"  # Default
                
        elif "Wind Load" in load_type:
            # Simplified wind pressure calculation
            # qz = 0.613 * Kz * Kzt * Kd * V^2 * I
            v = obj.WindSpeed  # m/s
            kz = 0.85  # Exposure factor
            kzt = 1.0  # Topographic factor
            kd = 0.85  # Directionality factor
            i = obj.ImportanceFactor
            
            qz = 0.613 * kz * kzt * kd * (v ** 2) * i / 1000  # kN/m²
            obj.LoadIntensity = f"{qz:.2f} kN/m^2"
    
    def updateLoadVisualization(self, obj) -> None:
        """
        Update visual representation of the load including distribution patterns.
        
        Args:
            obj: The DocumentObject
        """
        try:
            if not obj.ShowLoadArrows:
                self._clear_visualization(obj)
                return
                
            # Clear existing visualization
            self._clear_visualization(obj)
            
            # Create load vectors
            self._createLoadVectors(obj)
            
            # Show load distribution pattern if requested
            if obj.ShowLoadDistribution:
                self._createLoadDistribution(obj)
                
        except Exception as e:
            App.Console.PrintError(f"Error updating load visualization: {e}\n")
    
    def _createLoadVectors(self, obj) -> None:
        """
        Create load vector visualization.
        
        Args:
            obj: The DocumentObject
        """
        try:
            doc = App.ActiveDocument
            if not doc or not obj.TargetFaces:
                return
                
            visualization_objects = []
            
            # Get load properties
            direction_vector = self._get_direction_vector(obj)
            intensity = self.parseLoadIntensity(obj.LoadIntensity) if hasattr(obj, 'LoadIntensity') else 0.0
            arrow_scale = obj.VectorScale if hasattr(obj, 'VectorScale') else 1.0
            arrow_density = obj.DisplayDensity if hasattr(obj, 'DisplayDensity') else 10
            
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape'):
                    for face in face_obj.Shape.Faces:
                        # Get face boundaries
                        try:
                            u_range = face.ParameterRange[0:2]
                            v_range = face.ParameterRange[2:4]
                        except:
                            u_range = [0, 1]
                            v_range = [0, 1]
                        
                        # Get face normal at center
                        u_center = (u_range[0] + u_range[1]) / 2
                        v_center = (v_range[0] + v_range[1]) / 2
                        face_normal = face.normalAt(u_center, v_center)
                        
                        # Create arrows following load direction
                        for u_idx in range(arrow_density):
                            for v_idx in range(arrow_density):
                                u_param = u_range[0] + (u_range[1] - u_range[0]) * (u_idx + 0.5) / arrow_density
                                v_param = v_range[0] + (v_range[1] - v_range[0]) * (v_idx + 0.5) / arrow_density
                                
                                try:
                                    # Get point on surface
                                    point = face.valueAt(u_param, v_param)
                                    
                                    # Calculate projection factor
                                    proj_factor = abs(face_normal.x * direction_vector.x + 
                                                    face_normal.y * direction_vector.y + 
                                                    face_normal.z * direction_vector.z)
                                    
                                    # Create arrow with projected intensity
                                    arrow_obj = self._createArrow(doc, point, direction_vector, intensity * proj_factor, arrow_scale)
                                    if arrow_obj:
                                        visualization_objects.append(arrow_obj)
                                except Exception as e:
                                    continue  # Skip problematic points
            
            # Store visualization objects in the object
            obj.LoadVisualization = visualization_objects
        
        except Exception as e:
            App.Console.PrintError(f"Error creating load vectors: {e}\n")
    
    def _createArrow(self, doc, position, direction, magnitude, scale):
        """
        Create a load arrow at the specified position.
        
        Args:
            doc: FreeCAD document
            position: Position vector
            direction: Direction vector
            magnitude: Load magnitude
            scale: Scale factor
            
        Returns:
            Arrow object or None
        """
        try:
            # Calculate arrow length based on magnitude and scale
            arrow_length = magnitude * scale * 100  # Scale factor in mm
            if arrow_length < 10:  # Minimum length for visibility
                arrow_length = 10
            
            # Create arrow parts
            arrow_radius = arrow_length * 0.03  # Arrow shaft radius
            head_radius = arrow_radius * 3     # Arrow head radius
            head_length = arrow_length * 0.2   # Arrow head length
            
            # Create arrow shaft
            shaft_end = position + direction * (arrow_length - head_length)
            shaft = Part.makeCylinder(arrow_radius, arrow_length - head_length, position, direction)
            
            # Create arrow head (cone)
            head = Part.makeCone(head_radius, 0, head_length, shaft_end, direction)
            
            # Combine shaft and head
            arrow = Part.makeCompound([shaft, head])
            
            # Create arrow object
            arrow_name = f"LoadArrow_{App.ActiveDocument.ActiveObject.Name}_{len(doc.Objects)}"
            arrow_obj = doc.addObject("Part::Feature", arrow_name)
            arrow_obj.Shape = arrow
            
            # Set visual properties
            if hasattr(arrow_obj, 'ViewObject'):
                color = (0.8, 0.0, 0.8)  # Purple for load arrows
                arrow_obj.ViewObject.ShapeColor = color
                arrow_obj.ViewObject.LineColor = color
            
            return arrow_obj
        
        except Exception as e:
            App.Console.PrintWarning(f"Error creating arrow: {e}\n")
            return None
    
    def _createLoadDistribution(self, obj) -> None:
        """
        Create visual representation of load distribution pattern.
        
        Args:
            obj: The DocumentObject
        """
        try:
            doc = App.ActiveDocument
            if not doc or not obj.TargetFaces:
                return
            
            # Get distribution type
            distribution_type = "TwoWay"  # Default
            if hasattr(obj, 'LoadDistribution'):
                distribution_type = obj.LoadDistribution
            
            # Create distribution pattern based on type
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape'):
                    for i, face in enumerate(face_obj.Shape.Faces):
                        try:
                            # Create pattern lines based on distribution type
                            if distribution_type == "OneWay":
                                self._createOneWayPattern(obj, face)
                            elif distribution_type == "TwoWay":
                                self._createTwoWayPattern(obj, face)
                            elif distribution_type == "OpenStructure":
                                self._createOpenStructurePattern(obj, face)
                        
                        except Exception as e:
                            App.Console.PrintWarning(f"Error creating load distribution visualization: {e}\n")
        
        except Exception as e:
            App.Console.PrintError(f"Error creating load distribution visualization: {e}\n")
    
    def _createOneWayPattern(self, obj, face) -> None:
        """
        Create visual pattern for one-way load distribution.
        
        Args:
            obj: The DocumentObject
            face: The face to create pattern for
        """
        try:
            doc = App.ActiveDocument
            if not doc:
                return
                
            # Get one-way direction
            one_way_direction = App.Vector(1, 0, 0)  # Default X direction
            if hasattr(obj, 'OneWayDirection'):
                if obj.OneWayDirection == "X":
                    one_way_direction = App.Vector(1, 0, 0)
                elif obj.OneWayDirection == "Y":
                    one_way_direction = App.Vector(0, 1, 0)
                elif obj.OneWayDirection == "Custom" and hasattr(obj, 'CustomDistributionDirection'):
                    one_way_direction = obj.CustomDistributionDirection
            
            # Normalize direction
            length = math.sqrt(one_way_direction.x**2 + one_way_direction.y**2 + one_way_direction.z**2)
            if length > 0:
                one_way_direction = App.Vector(one_way_direction.x/length, one_way_direction.y/length, one_way_direction.z/length)
            
            # Create pattern lines parallel to one-way direction
            # This visual pattern would show the direction of the one-way load
            # For now, we'll create a simple representation
            center = face.CenterOfMass
            face_normal = face.normalAt(0.5, 0.5)
            
            # Create a line in the one-way direction
            line_length = 50  # mm
            start_point = center - one_way_direction * line_length/2
            end_point = center + one_way_direction * line_length/2
            line = Part.makeLine(start_point, end_point)
            
            # Create line object
            line_name = f"OneWayPattern_{obj.Label}"
            line_obj = doc.addObject("Part::Feature", line_name)
            line_obj.Shape = line
            
            # Set visual properties
            if hasattr(line_obj, 'ViewObject'):
                line_obj.ViewObject.LineColor = (0.0, 0.0, 1.0)  # Blue for one-way pattern
                line_obj.ViewObject.LineWidth = 3
            
            # Add to visualization objects if not already there
            if hasattr(obj, 'LoadVisualization'):
                obj.LoadVisualization.append(line_obj)
                
        except Exception as e:
            App.Console.PrintWarning(f"Error creating one-way pattern: {e}\n")
    
    def _createTwoWayPattern(self, obj, face) -> None:
        """
        Create visual pattern for two-way load distribution.
        
        Args:
            obj: The DocumentObject
            face: The face to create pattern for
        """
        try:
            doc = App.ActiveDocument
            if not doc:
                return
                
            # For two-way distribution, create an X pattern
            # This visual pattern would show the two-way load distribution
            center = face.CenterOfMass
            
            # Get face boundaries to determine size
            try:
                bbox = face.BoundBox
                size = min(bbox.XLength, bbox.YLength, bbox.ZLength) / 4
            except:
                size = 25  # Default size
            
            # Create X pattern
            x_pattern = []
            
            # First diagonal
            p1 = center + App.Vector(size, size, 0)
            p2 = center + App.Vector(-size, -size, 0)
            line1 = Part.makeLine(p1, p2)
            x_pattern.append(line1)
            
            # Second diagonal
            p3 = center + App.Vector(size, -size, 0)
            p4 = center + App.Vector(-size, size, 0)
            line2 = Part.makeLine(p3, p4)
            x_pattern.append(line2)
            
            # Create compound
            pattern_compound = Part.makeCompound(x_pattern)
            
            # Create pattern object
            pattern_name = f"TwoWayPattern_{obj.Label}"
            pattern_obj = doc.addObject("Part::Feature", pattern_name)
            pattern_obj.Shape = pattern_compound
            
            # Set visual properties
            if hasattr(pattern_obj, 'ViewObject'):
                pattern_obj.ViewObject.LineColor = (0.0, 1.0, 0.0)  # Green for two-way pattern
                pattern_obj.ViewObject.LineWidth = 3
            
            # Add to visualization objects if not already there
            if hasattr(obj, 'LoadVisualization'):
                obj.LoadVisualization.append(pattern_obj)
                
        except Exception as e:
            App.Console.PrintWarning(f"Error creating two-way pattern: {e}\n")
    
    def _createOpenStructurePattern(self, obj, face) -> None:
        """
        Create visual pattern for open structure load distribution.
        
        Args:
            obj: The DocumentObject
            face: The face to create pattern for
        """
        try:
            doc = App.ActiveDocument
            if not doc:
                return
                
            # For open structure, create a grid pattern
            center = face.CenterOfMass
            
            # Get face boundaries to determine size
            try:
                bbox = face.BoundBox
                width = bbox.XLength / 4
                height = bbox.YLength / 4
            except:
                width = 25  # Default width
                height = 25  # Default height
            
            # Create grid pattern
            grid_pattern = []
            
            # Horizontal lines
            for i in range(-2, 3):
                y_offset = i * height / 2
                p1 = center + App.Vector(-width, y_offset, 0)
                p2 = center + App.Vector(width, y_offset, 0)
                line = Part.makeLine(p1, p2)
                grid_pattern.append(line)
            
            # Vertical lines
            for i in range(-2, 3):
                x_offset = i * width / 2
                p1 = center + App.Vector(x_offset, -height, 0)
                p2 = center + App.Vector(x_offset, height, 0)
                line = Part.makeLine(p1, p2)
                grid_pattern.append(line)
            
            # Create compound
            pattern_compound = Part.makeCompound(grid_pattern)
            
            # Create pattern object
            pattern_name = f"OpenStructurePattern_{obj.Label}"
            pattern_obj = doc.addObject("Part::Feature", pattern_name)
            pattern_obj.Shape = pattern_compound
            
            # Set visual properties
            if hasattr(pattern_obj, 'ViewObject'):
                pattern_obj.ViewObject.LineColor = (1.0, 1.0, 0.0)  # Yellow for open structure pattern
                pattern_obj.ViewObject.LineWidth = 2
            
            # Add to visualization objects if not already there
            if hasattr(obj, 'LoadVisualization'):
                obj.LoadVisualization.append(pattern_obj)
                
        except Exception as e:
            App.Console.PrintWarning(f"Error creating open structure pattern: {e}\n")
    
    def _clear_visualization(self, obj) -> None:
        """
        Clear existing load visualization objects.
        
        Args:
            obj: The DocumentObject
        """
        try:
            doc = App.ActiveDocument
            if not doc:
                return
            
            # Remove all visualization objects
            if hasattr(obj, 'LoadVisualization') and obj.LoadVisualization:
                for vis_obj in obj.LoadVisualization:
                    if vis_obj and hasattr(doc, 'getObject') and doc.getObject(vis_obj.Name):
                        doc.removeObject(vis_obj.Name)
                
                # Clear visualization list
                obj.LoadVisualization = []
        
        except Exception as e:
            App.Console.PrintWarning(f"Error clearing visualization: {e}\n")
    
    def execute(self, obj):
        """Update load visualization and integration."""
        if obj.TargetFaces:
            self.updateLoadVisualization(obj)
            self.calculateTotalLoad(obj)
    
    def updateLoadVisualization(self, obj):
        """Update visual representation of the load."""
        try:
            if not obj.ShowLoadVectors:
                return
                
            # Clear existing visualization
            doc = App.ActiveDocument
            if not doc:
                return
                
            # Create load vectors
            self.createLoadVectors(obj)
            
            # Show load distribution if requested
            if obj.ShowLoadDistribution:
                self.createLoadDistribution(obj)
                
        except Exception as e:
            App.Console.PrintError(f"Error updating load visualization: {e}\n")
    
    def createLoadVectors(self, obj):
        """Create load vector visualization."""
        try:
            doc = App.ActiveDocument
            if not doc or not obj.TargetFaces:
                return
                
            for i, face_obj in enumerate(obj.TargetFaces):
                if hasattr(face_obj, 'Shape'):
                    # Get face center
                    center = face_obj.Shape.CenterOfMass
                    
                    # Calculate load direction and magnitude
                    direction = obj.LoadDirection
                    if obj.ProjectToSurface and hasattr(face_obj.Shape, 'normalAt'):
                        # Use surface normal
                        u, v = face_obj.Shape.Surface.parameter(center)
                        direction = face_obj.Shape.normalAt(u, v)
                        direction = direction * -1  # Point inward for loads
                    
                    # Create arrow for visualization
                    self.createLoadArrow(doc, center, direction, obj, i)
                    
        except Exception as e:
            App.Console.PrintError(f"Error creating load vectors: {e}\n")
    
    def createLoadArrow(self, doc, position, direction, load_obj, index):
        """Create a single load arrow."""
        try:
            arrow_name = f"LoadArrow_{load_obj.Label}_{index}"
            
            # Remove existing arrow
            if hasattr(doc, 'getObject') and doc.getObject(arrow_name):
                doc.removeObject(arrow_name)
            
            # Create arrow geometry
            arrow_length = 100.0 * load_obj.VectorScale  # mm
            arrow_head = 20.0  # mm
            
            # Scale by load magnitude
            intensity = self.parseLoadIntensity(load_obj.LoadIntensity)
            if intensity > 0:
                arrow_length *= min(intensity / 2.4, 5.0)  # Scale relative to 2.4 kN/m²
            
            direction_norm = direction.normalize()
            end_point = position + (direction_norm * arrow_length)
            
            # Create arrow shaft
            shaft = Part.makeCylinder(2.0, arrow_length)
            
            # Create arrow head
            cone = Part.makeCone(0, 8.0, arrow_head)
            cone.translate(App.Vector(0, 0, arrow_length))
            
            # Combine shaft and head
            arrow = shaft.fuse(cone)
            
            # Rotate to align with direction
            # (Implementation would need proper rotation matrix)
            
            # Create object
            arrow_obj = doc.addObject("Part::Feature", arrow_name)
            arrow_obj.Shape = arrow
            arrow_obj.Placement.Base = position
            
            # Set color
            if hasattr(arrow_obj, 'ViewObject'):
                color = load_obj.LoadColor if hasattr(load_obj, 'LoadColor') else (1.0, 0.0, 0.0)
                arrow_obj.ViewObject.ShapeColor = color
                arrow_obj.ViewObject.LineColor = color
                
        except Exception as e:
            App.Console.PrintError(f"Error creating load arrow: {e}\n")
    
    def calculateTotalLoad(self, obj):
        """Calculate total load and moments."""
        try:
            if not obj.TargetFaces:
                return
                
            total_force = 0.0
            moment_x = 0.0
            moment_y = 0.0
            
            intensity = self.parseLoadIntensity(obj.LoadIntensity)
            
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape'):
                    area = face_obj.Shape.Area / 1000000  # Convert mm² to m²
                    force = intensity * area  # kN
                    total_force += force
                    
                    # Calculate moments about origin
                    center = face_obj.Shape.CenterOfMass
                    moment_x += force * (center.y / 1000)  # kN⋅m
                    moment_y += force * (center.x / 1000)  # kN⋅m
            
            obj.TotalForce = f"{total_force:.2f} kN"
            obj.MomentX = moment_x
            obj.MomentY = moment_y
            
        except Exception as e:
            App.Console.PrintError(f"Error calculating total load: {e}\n")
        
        # Load magnitude and direction
        obj.addProperty("App::PropertyPressure", "Magnitude", "Load",
                       "Load magnitude per unit area")
        obj.Magnitude = "5.0 kN/m^2"
        
        obj.addProperty("App::PropertyEnumeration", "Direction", "Load",
                       "Load direction")
        obj.Direction = ["Normal", "+X Global", "-X Global", "+Y Global", "-Y Global", "+Z Global", "-Z Global", "Custom"]
        obj.Direction = "Normal"
        
        obj.addProperty("App::PropertyVector", "CustomDirection", "Load",
                       "Custom load direction vector (normalized)")
        obj.CustomDirection = App.Vector(0, 0, -1)
        
        # Load distribution
        obj.addProperty("App::PropertyEnumeration", "Distribution", "Distribution",
                       "Load distribution pattern")
        obj.Distribution = ["Uniform", "Linear X", "Linear Y", "Bilinear", "Parabolic", "Point Load", "User Defined"]
        obj.Distribution = "Uniform"
        
        obj.addProperty("App::PropertyFloatList", "DistributionParameters", "Distribution",
                       "Parameters for distribution pattern")
        obj.DistributionParameters = [1.0]  # Default uniform
        
        obj.addProperty("App::PropertyString", "DistributionFunction", "Distribution",
                       "Custom distribution function (Python expression)")
        obj.DistributionFunction = "1.0"  # Default uniform
        
        # Spatial variation
        obj.addProperty("App::PropertyVector", "VariationCenter", "Distribution",
                       "Center point for load variation")
        
        obj.addProperty("App::PropertyFloat", "VariationRadius", "Distribution",
                       "Characteristic radius for load variation (mm)")
        obj.VariationRadius = 1000.0
        
        # Load case information
        obj.addProperty("App::PropertyString", "LoadCaseName", "Case",
                       "Load case name/identifier")
        obj.LoadCaseName = "DL1"
        
        obj.addProperty("App::PropertyString", "LoadCombination", "Case",
                       "Load combination identifier")
        obj.LoadCombination = ""
        
        obj.addProperty("App::PropertyFloat", "LoadFactor", "Case",
                       "Load factor for combinations")
        obj.LoadFactor = 1.0
        
        # Time variation
        obj.addProperty("App::PropertyBool", "IsTimeDependent", "Time",
                       "Time-dependent load")
        obj.IsTimeDependent = False
        
        obj.addProperty("App::PropertyEnumeration", "TimeFunction", "Time",
                       "Time variation function")
        obj.TimeFunction = ["Constant", "Linear", "Sinusoidal", "Custom"]
        obj.TimeFunction = "Constant"
        
        obj.addProperty("App::PropertyFloatList", "TimeParameters", "Time",
                       "Parameters for time function")
        obj.TimeParameters = [1.0]
        
        obj.addProperty("App::PropertyFloat", "Duration", "Time",
                       "Load duration (seconds)")
        obj.Duration = 0.0
        
        # Thermal properties (for thermal loads)
        obj.addProperty("App::PropertyFloat", "Temperature", "Thermal",
                       "Temperature change (°C)")
        obj.Temperature = 0.0
        
        obj.addProperty("App::PropertyFloat", "TemperatureGradient", "Thermal",
                       "Temperature gradient through thickness (°C/mm)")
        obj.TemperatureGradient = 0.0
        
        # Wind load properties
        obj.addProperty("App::PropertyFloat", "WindSpeed", "Wind",
                       "Design wind speed (m/s)")
        obj.WindSpeed = 0.0
        
        obj.addProperty("App::PropertyFloat", "PressureCoefficient", "Wind",
                       "Wind pressure coefficient")
        obj.PressureCoefficient = 1.0
        
        obj.addProperty("App::PropertyEnumeration", "WindDirection", "Wind",
                       "Wind direction")
        obj.WindDirection = ["0°", "45°", "90°", "135°", "180°", "225°", "270°", "315°"]
        obj.WindDirection = "0°"
        
        # Visualization properties
        obj.addProperty("App::PropertyBool", "ShowLoadArrows", "Visualization",
                       "Show load arrows")
        obj.ShowLoadArrows = True
        
        obj.addProperty("App::PropertyInteger", "ArrowDensity", "Visualization",
                       "Number of arrows per edge")
        obj.ArrowDensity = 5
        
        obj.addProperty("App::PropertyFloat", "ArrowScale", "Visualization",
                       "Arrow scale factor")
        obj.ArrowScale = 1.0
        
        obj.addProperty("App::PropertyColor", "LoadColor", "Visualization",
                       "Load visualization color")
        obj.LoadColor = (1.0, 0.0, 0.0)  # Red
        
        # Analysis integration
        obj.addProperty("App::PropertyPythonObject", "LoadVisualization", "Internal",
                       "Load arrow visualization objects")
        obj.LoadVisualization = []
        
        obj.addProperty("App::PropertyVector", "LoadCenter", "Application",
                       "Center point of the load application")
        obj.LoadCenter = App.Vector(0, 0, 0)
        
        # Results and integration
        obj.addProperty("App::PropertyForce", "TotalLoad", "Results",
                       "Total applied load")
        obj.TotalLoad = 0.0
                
        obj.addProperty("App::PropertyVector", "LoadResultant", "Results",
                       "Resultant load vector")
        obj.LoadResultant = App.Vector(0, 0, 0)
                
        obj.addProperty("App::PropertyBool", "IsValid", "Validation",
                       "Whether the load definition is valid")
        obj.IsValid = True
        
        # Visualization properties
        obj.addProperty("App::PropertyBool", "ShowLoadArrows", "Display",
                       "Show load arrows")
        obj.ShowLoadArrows = True
                
        obj.addProperty("App::PropertyFloat", "ArrowScale", "Display",
                       "Scale factor for load arrows")
        obj.ArrowScale = 1.0
                
        obj.addProperty("App::PropertyInteger", "ArrowDensity", "Display",
                       "Density of load arrows")
        obj.ArrowDensity = 5
                
        obj.addProperty("App::PropertyColor", "LoadColor", "Display",
                       "Color for load display")
        obj.LoadColor = (1.0, 0.0, 0.0)  # Red
                
        obj.addProperty("App::PropertyLinkList", "LoadVisualization", "Display",
                       "Visualization objects for the load")
        obj.LoadVisualization = []
                
        obj.addProperty("App::PropertyBool", "ShowLoadDistribution", "Display",
                       "Show load distribution pattern")
        obj.ShowLoadDistribution = True
                
        obj.addProperty("App::PropertyInteger", "DisplayDensity", "Display",
                       "Density of load visualization")
        obj.DisplayDensity = 10
        
        # Identification
        obj.addProperty("App::PropertyString", "LoadID", "Identification",
                       "Unique load identifier")
        
        obj.addProperty("App::PropertyString", "Description", "Identification",
                       "Load description or notes")
        
        obj.addProperty("App::PropertyString", "DesignCode", "Identification",
                       "Applicable design code")
        obj.DesignCode = "IBC 2018"
        
        # Status
        obj.addProperty("App::PropertyBool", "IsActive", "Status",
                       "Load is active in analysis")
        obj.IsActive = True
        
        obj.addProperty("App::PropertyBool", "IsValid", "Status",
                       "Load definition is valid")
        obj.IsValid = True
    
    def onChanged(self, obj, prop: str) -> None:
        """
        Handle property changes with validation and updates.
        
        Args:
            obj: The DocumentObject being changed
            prop: Name of the changed property
        """
        # Ensure critical properties exist
        if not hasattr(obj, 'LoadCategory'):
            self._ensure_property_exists("App::PropertyEnumeration", "LoadCategory", "Load",
                       "Load category for combinations", "DL")
        
        if not hasattr(obj, 'ShowLoadArrows'):
            self._ensure_property_exists("App::PropertyBool", "ShowLoadArrows", "Display",
                       "Show load arrows", True)
        
        if not hasattr(obj, 'LoadCenter'):
            self._ensure_property_exists("App::PropertyVector", "LoadCenter", "Application",
                       "Center point of the load application", App.Vector(0, 0, 0))
        
        # Handle property changes
        if prop == "TargetFaces":
            self._update_loaded_area(obj)
            self._update_load_center(obj)
        elif prop == "LoadType":
            self._update_load_category(obj)
        elif prop in ["Magnitude", "Distribution", "DistributionParameters"]:
            self._calculate_total_load(obj)
        elif prop == "Direction":
            self._update_direction_vector(obj)
        elif prop == "LoadDistribution":
            # Handle changes in load distribution method
            self._update_distribution_visualization(obj)
        elif prop == "OneWayDirection":
            # Update custom direction when one-way direction changes
            self._update_one_way_direction(obj)
        elif hasattr(obj, 'ShowLoadArrows') and prop == "ShowLoadArrows":
            self._update_visualization(obj)
        elif prop in ["ArrowDensity", "ArrowScale"]:
            if hasattr(obj, 'ShowLoadArrows') and obj.ShowLoadArrows:
                self._update_visualization(obj)
    
    def _update_loaded_area(self, obj) -> None:
        """Calculate total loaded area from target faces."""
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces:
            obj.LoadedArea = "0 mm^2"
            return
        
        total_area = 0.0
        for face_obj in obj.TargetFaces:
            if hasattr(face_obj, 'Shape'):
                shape = face_obj.Shape
                if hasattr(shape, 'Faces'):
                    for face in shape.Faces:
                        total_area += face.Area
                elif hasattr(shape, 'Area'):
                    total_area += shape.Area
        
        obj.LoadedArea = f"{total_area} mm^2"
        App.Console.PrintMessage(f"Updated loaded area: {total_area:.2f} mm²\n")
    
    def _update_load_category(self, obj) -> None:
        """Update load category based on load type."""
        if not hasattr(obj, 'LoadType') or not hasattr(obj, 'LoadCategory'):
            return
        
        load_type = obj.LoadType
        category_map = {
            "Dead Load (DL)": "DL",
            "Live Load (LL)": "LL", 
            "Live Load Roof (LL_Roof)": "LL_Roof",
            "Wind Load (W)": "W",
            "Earthquake (E)": "E",
            "Earth Pressure (H)": "H",
            "Fluid Pressure (F)": "F",
            "Thermal (T)": "T",
            "Custom Pressure": "CUSTOM"
        }
        
        if load_type in category_map:
            obj.LoadCategory = category_map[load_type]
    
    def _calculate_total_load(self, obj) -> None:
        """Calculate total applied load."""
        if not hasattr(obj, 'LoadedArea') or not hasattr(obj, 'Magnitude'):
            return
        
        try:
            area = obj.LoadedArea.getValueAs('mm^2')
            magnitude = obj.Magnitude.getValueAs('N/mm^2')  # Convert to N/mm²
            
            # Apply distribution factor
            distribution_factor = 1.0
            if hasattr(obj, 'Distribution') and obj.Distribution != "Uniform":
                distribution_factor = self._get_distribution_factor(obj)
            
            total_load = magnitude * area * distribution_factor
            obj.TotalLoad = total_load
            
            # Calculate load resultant vector
            direction_vector = self._get_direction_vector(obj)
            obj.LoadResultant = direction_vector * total_load
            
            App.Console.PrintMessage(f"Total load calculated: {total_load:.2f} N\n")
            
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating total load: {e}\n")
            obj.TotalLoad = 0.0
    
    def _get_distribution_factor(self, obj) -> float:
        """Get distribution factor based on distribution type."""
        if not hasattr(obj, 'Distribution'):
            return 1.0
        
        distribution = obj.Distribution
        
        if distribution == "Uniform":
            return 1.0
        elif distribution in ["Linear X", "Linear Y"]:
            # For linear distribution, average is 0.5 * (min + max)
            # Assuming parameters are [min_factor, max_factor]
            if len(obj.DistributionParameters) >= 2:
                return 0.5 * (obj.DistributionParameters[0] + obj.DistributionParameters[1])
            return 1.0
        elif distribution == "Parabolic":
            # For parabolic distribution, integrate over area
            return 2.0/3.0  # Simplified
        elif distribution == "Point Load":
            return 1.0  # Full load at a point
        else:
            return 1.0
    
    def _update_distribution_visualization(self, obj) -> None:
        """Update visualization based on load distribution method."""
        if not hasattr(obj, 'LoadDistribution'):
            return
            
        # Clear existing visualization
        self._clear_visualization(obj)
        
        # Update visualization based on distribution method
        if hasattr(obj, 'ShowLoadArrows') and obj.ShowLoadArrows:
            self._create_load_arrows(obj)
            
        # Calculate edge factors based on distribution method
        if hasattr(obj, 'EdgeDistributionFactors'):
            if obj.LoadDistribution == "OneWay":
                # For one-way distribution, calculate edge factors based on direction
                self._calculate_one_way_edge_factors(obj)
            elif obj.LoadDistribution == "TwoWay":
                # For two-way distribution, calculate tributary areas
                self._calculate_two_way_edge_factors(obj)
            elif obj.LoadDistribution == "OpenStructure":
                # For open structure, use projected area
                self._calculate_projected_edge_factors(obj)
    
    def _update_one_way_direction(self, obj) -> None:
        """Update custom direction vector based on one-way direction selection."""
        if not hasattr(obj, 'OneWayDirection') or not hasattr(obj, 'CustomDistributionDirection'):
            return
            
        # Set default direction vector based on selection
        if obj.OneWayDirection == "X":
            obj.CustomDistributionDirection = App.Vector(1, 0, 0)
        elif obj.OneWayDirection == "Y":
            obj.CustomDistributionDirection = App.Vector(0, 1, 0)
            
        # Update visualization
        self._update_distribution_visualization(obj)
    
    def _calculate_one_way_edge_factors(self, obj) -> None:
        """Calculate edge distribution factors for one-way load distribution."""
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces:
            return
            
        # Default equal distribution
        edge_factors = [1.0, 1.0, 1.0, 1.0]
        
        # Get one-way direction
        direction = App.Vector(1, 0, 0)  # Default X direction
        if hasattr(obj, 'OneWayDirection'):
            if obj.OneWayDirection == "X":
                direction = App.Vector(1, 0, 0)
            elif obj.OneWayDirection == "Y":
                direction = App.Vector(0, 1, 0)
            elif obj.OneWayDirection == "Custom" and hasattr(obj, 'CustomDistributionDirection'):
                direction = obj.CustomDistributionDirection
                
        try:
            # Normalize direction
            length = math.sqrt(direction.x**2 + direction.y**2 + direction.z**2)
            if length > 0:
                direction = App.Vector(direction.x/length, direction.y/length, direction.z/length)
                
            # For each target face, find edges parallel to direction
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape'):
                    shape = face_obj.Shape
                    if hasattr(shape, 'Faces'):
                        for face in shape.Faces:
                            # Find edges parallel and perpendicular to direction
                            parallel_edges = []
                            perpendicular_edges = []
                            
                            for i, edge in enumerate(face.Edges):
                                if edge.Length > 0:
                                    edge_dir = edge.Vertexes[1].Point - edge.Vertexes[0].Point
                                    edge_length = math.sqrt(edge_dir.x**2 + edge_dir.y**2 + edge_dir.z**2)
                                    if edge_length > 0:
                                        edge_dir = App.Vector(edge_dir.x/edge_length, edge_dir.y/edge_length, edge_dir.z/edge_length)
                                        # Check if edge is parallel to direction (using dot product)
                                        edge_dot = abs(edge_dir.x * direction.x + edge_dir.y * direction.y + edge_dir.z * direction.z)
                                        if edge_dot > 0.7:  # If dot product is close to 1, they're parallel
                                            parallel_edges.append(i)
                                        else:
                                            perpendicular_edges.append(i)
                            
                            # For one-way distribution, load goes to perpendicular edges
                            if len(perpendicular_edges) >= 2:
                                # Reset factors to 0
                                edge_factors = [0.0, 0.0, 0.0, 0.0]
                                
                                # Set perpendicular edges to 0.5 each (shared load)
                                for i in perpendicular_edges[:2]:  # Use first two perpendicular edges
                                    if i < len(edge_factors):
                                        edge_factors[i] = 0.5
            
            # Update edge distribution factors
            obj.EdgeDistributionFactors = edge_factors
            
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating one-way edge factors: {e}\n")
    
    def _calculate_two_way_edge_factors(self, obj) -> None:
        """Calculate edge distribution factors for two-way load distribution."""
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces:
            return
            
        # Default equal distribution to all edges
        edge_factors = [0.25, 0.25, 0.25, 0.25]  # Equal distribution to all edges
        
        try:
            # For each target face, calculate edge factors based on tributary areas
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape'):
                    shape = face_obj.Shape
                    if hasattr(shape, 'Faces'):
                        for face in shape.Faces:
                            # Get edge lengths
                            edge_lengths = [edge.Length for edge in face.Edges[:4]]  # Use first 4 edges
                            
                            # Calculate edge factors based on relative lengths
                            # For a rectangle, longer edges get more load (simplified calculation)
                            total_length = sum(edge_lengths)
                            
                            if total_length > 0:
                                edge_factors = [length/total_length for length in edge_lengths]
                                
                                # Pad to 4 elements if needed
                                while len(edge_factors) < 4:
                                    edge_factors.append(0.0)
            
            # Update edge distribution factors
            obj.EdgeDistributionFactors = edge_factors
            
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating two-way edge factors: {e}\n")
    
    def _calculate_projected_edge_factors(self, obj) -> None:
        """Calculate edge distribution factors for open structure load distribution."""
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces:
            return
            
        # For open structure, load is distributed based on projected areas
        # This is a simplified implementation; real-world calculation would be more complex
        edge_factors = [0.25, 0.25, 0.25, 0.25]  # Default equal distribution
        
        try:
            # Get load direction
            load_direction = App.Vector(0, 0, -1)  # Default downward
            if hasattr(obj, 'LoadDirection'):
                load_direction = obj.LoadDirection
                
            # Normalize direction
            length = math.sqrt(load_direction.x**2 + load_direction.y**2 + load_direction.z**2)
            if length > 0:
                load_direction = App.Vector(load_direction.x/length, load_direction.y/length, load_direction.z/length)
                
            # For each target face, calculate projected areas
            for face_obj in obj.TargetFaces:
                if hasattr(face_obj, 'Shape'):
                    shape = face_obj.Shape
                    if hasattr(shape, 'Faces'):
                        for face in shape.Faces:
                            # Calculate face normal
                            face_normal = face.normalAt(0.5, 0.5)
                            
                            # Get projection factor (dot product with load direction)
                            proj_factor = abs(face_normal.x * load_direction.x + 
                                             face_normal.y * load_direction.y + 
                                             face_normal.z * load_direction.z)
                            
                            # Calculate edge factors based on projection and edge orientation
                            # This is a placeholder for a more complex calculation
                            # In a real implementation, you would calculate projected areas for each edge
                            
                            # For demonstration, we'll just use the projection factor to adjust edge factors
                            edge_factors = [0.25 * proj_factor] * 4
            
            # Update edge distribution factors
            obj.EdgeDistributionFactors = edge_factors
            
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating projected edge factors: {e}\n")
    
    def _get_direction_vector(self, obj) -> App.Vector:
        """Get normalized direction vector for load."""
        if not hasattr(obj, 'Direction'):
            return App.Vector(0, 0, -1)
        
        direction = obj.Direction
        
        if direction == "Normal":
            return self._get_surface_normal(obj)
        elif direction == "+X Global":
            return App.Vector(1, 0, 0)
        elif direction == "-X Global":
            return App.Vector(-1, 0, 0)
        elif direction == "+Y Global":
            return App.Vector(0, 1, 0)
        elif direction == "-Y Global":
            return App.Vector(0, -1, 0)
        elif direction == "+Z Global":
            return App.Vector(0, 0, 1)
        elif direction == "-Z Global":
            return App.Vector(0, 0, -1)
        elif direction == "Custom":
            if hasattr(obj, 'CustomDirection'):
                custom = obj.CustomDirection
                # Normalize the vector
                length = math.sqrt(custom.x**2 + custom.y**2 + custom.z**2)
                if length > 0:
                    return App.Vector(custom.x/length, custom.y/length, custom.z/length)
            return App.Vector(0, 0, -1)
        else:
            return App.Vector(0, 0, -1)
    
    def _get_surface_normal(self, obj) -> App.Vector:
        """Get average surface normal from target faces."""
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces:
            return App.Vector(0, 0, -1)
        
        total_normal = App.Vector(0, 0, 0)
        face_count = 0
        
        for face_obj in obj.TargetFaces:
            if hasattr(face_obj, 'Shape'):
                shape = face_obj.Shape
                if hasattr(shape, 'Faces'):
                    for face in shape.Faces:
                        try:
                            normal = face.normalAt(0.5, 0.5)  # Normal at center
                            total_normal = total_normal + normal
                            face_count += 1
                        except:
                            continue
        
        if face_count > 0:
            avg_normal = total_normal * (1.0 / face_count)
            length = math.sqrt(avg_normal.x**2 + avg_normal.y**2 + avg_normal.z**2)
            if length > 0:
                return App.Vector(avg_normal.x/length, avg_normal.y/length, avg_normal.z/length)
        
        return App.Vector(0, 0, -1)
    
    def _update_direction_vector(self, obj) -> None:
        """Update direction vector when direction changes."""
        self._calculate_total_load(obj)
    
    def _update_load_center(self, obj) -> None:
        """Calculate center of load application."""
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces or not hasattr(obj, 'LoadCenter'):
            if hasattr(obj, 'LoadCenter'):
                obj.LoadCenter = App.Vector(0, 0, 0)
            return
        
        total_area = 0.0
        weighted_center = App.Vector(0, 0, 0)
        
        for face_obj in obj.TargetFaces:
            if hasattr(face_obj, 'Shape'):
                shape = face_obj.Shape
                if hasattr(shape, 'Faces'):
                    for face in shape.Faces:
                        area = face.Area
                        center = face.CenterOfMass
                        weighted_center = weighted_center + (center * area)
                        total_area += area
        
        if total_area > 0:
            obj.LoadCenter = weighted_center * (1.0 / total_area)
        else:
            obj.LoadCenter = App.Vector(0, 0, 0)
    
    def _update_visualization(self, obj) -> None:
        """Update load arrow visualization."""
        if not hasattr(obj, 'ShowLoadArrows') or not obj.ShowLoadArrows:
            self._clear_visualization(obj)
            return
        
        self._create_load_arrows(obj)
    
    def _clear_visualization(self, obj) -> None:
        """Clear existing load visualization."""
        if hasattr(obj, 'LoadVisualization') and obj.LoadVisualization:
            doc = App.ActiveDocument
            for vis_obj in obj.LoadVisualization:
                if hasattr(vis_obj, 'Name') and doc.getObject(vis_obj.Name):
                    doc.removeObject(vis_obj.Name)
            obj.LoadVisualization = []
    
    def _create_load_arrows(self, obj) -> None:
        """Create 3D arrows for load visualization."""
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces:
            return
        
        self._clear_visualization(obj)
        
        direction_vector = self._get_direction_vector(obj)
        magnitude = obj.Magnitude.getValueAs('N/mm^2') if hasattr(obj, 'Magnitude') else 0.0
        scale = obj.ArrowScale if hasattr(obj, 'ArrowScale') else 1.0
        density = obj.ArrowDensity if hasattr(obj, 'ArrowDensity') else 5
        
        arrow_objects = []
        
        for face_obj in obj.TargetFaces:
            if hasattr(face_obj, 'Shape'):
                shape = face_obj.Shape
                if hasattr(shape, 'Faces'):
                    for face in shape.Faces:
                        arrows = self._create_arrows_on_face(obj, face, direction_vector, magnitude, scale, density)
                        arrow_objects.extend(arrows)
        
        obj.LoadVisualization = arrow_objects
    
    def _create_arrows_on_face(self, obj, face, direction, magnitude, scale, density) -> List:
        """Create arrows on a specific face."""
        arrows = []
        
        try:
            # Create grid of points on face
            u_params = np.linspace(0.1, 0.9, density)
            v_params = np.linspace(0.1, 0.9, density)
            
            for u in u_params:
                for v in v_params:
                    try:
                        # Get point on surface
                        point = face.valueAt(u, v)
                        
                        # Get load magnitude at this point
                        local_magnitude = self._get_load_at_point(obj, point, magnitude)
                        
                        # Create arrow
                        arrow = self._create_single_arrow(point, direction, local_magnitude, scale)
                        if arrow:
                            arrows.append(arrow)
                            
                    except Exception as e:
                        continue  # Skip problematic points
        
        except Exception as e:
            App.Console.PrintWarning(f"Error creating arrows on face: {e}\n")
        
        return arrows
    
    def _get_load_at_point(self, obj, point: App.Vector, base_magnitude: float) -> float:
        """Get load magnitude at a specific point based on distribution."""
        if not hasattr(obj, 'Distribution'):
            return base_magnitude
        
        distribution = obj.Distribution
        
        if distribution == "Uniform":
            return base_magnitude
        elif distribution == "Linear X":
            # Simplified linear variation in X direction
            if len(obj.DistributionParameters) >= 2:
                min_factor = obj.DistributionParameters[0]
                max_factor = obj.DistributionParameters[1]
                # Assume variation from 0 to face width
                factor = min_factor + (max_factor - min_factor) * 0.5  # Simplified
                return base_magnitude * factor
        # Add more distribution types as needed
        
        return base_magnitude
    
    def _create_single_arrow(self, start_point: App.Vector, direction: App.Vector, magnitude: float, scale: float):
        """Create a single load arrow."""
        try:
            doc = App.ActiveDocument
            
            # Calculate arrow length based on magnitude and scale
            arrow_length = magnitude * scale * 100  # Scale factor
            if arrow_length < 10:  # Minimum arrow length
                arrow_length = 10
            
            # Create arrow geometry
            end_point = start_point + (direction * arrow_length)
            
            # Create arrow line
            arrow_line = Part.makeLine(start_point, end_point)
            
            # Create arrow head (cone)
            head_radius = arrow_length * 0.1
            head_height = arrow_length * 0.2
            head_center = end_point - (direction * head_height * 0.5)
            
            # Create cone for arrow head
            cone = Part.makeCone(0, head_radius, head_height, head_center, direction)
            
            # Combine line and cone
            arrow_shape = Part.makeCompound([arrow_line, cone])
            
            # Create FreeCAD object
            arrow_obj = doc.addObject("Part::Feature", f"LoadArrow_{obj.Label}")
            arrow_obj.Shape = arrow_shape
            
            # Set visual properties
            if App.GuiUp:
                arrow_obj.ViewObject.ShapeColor = obj.LoadColor if hasattr(obj, 'LoadColor') else (1.0, 0.0, 0.0)
                arrow_obj.ViewObject.LineColor = obj.LoadColor if hasattr(obj, 'LoadColor') else (1.0, 0.0, 0.0)
                arrow_obj.ViewObject.Transparency = 20
            
            return arrow_obj
            
        except Exception as e:
            App.Console.PrintWarning(f"Error creating arrow: {e}\n")
            return None
    
    def execute(self, obj) -> None:
        """
        Update area load and validate properties.
        
        Args:
            obj: The DocumentObject being executed
        """
        # Update geometric properties
        self._update_loaded_area(obj)
        if hasattr(obj, 'LoadCenter'):
            self._update_load_center(obj)
        
        # Calculate loads
        self._calculate_total_load(obj)
        
        # Update visualization
        if hasattr(obj, 'ShowLoadArrows') and obj.ShowLoadArrows:
            self.updateLoadVisualization(obj)
        
        # Validate load definition
        self._validate_load(obj)
    
    def _validate_load(self, obj) -> None:
        """Validate load definition and set validity flag."""
        is_valid = True
        warnings = []
        
        # Check if target faces exist
        if not hasattr(obj, 'TargetFaces') or not obj.TargetFaces:
            is_valid = False
            warnings.append("No target faces defined")
        
        # Check magnitude
        if hasattr(obj, 'Magnitude'):
            try:
                mag = obj.Magnitude.getValueAs('N/mm^2')
                if mag <= 0:
                    warnings.append("Load magnitude should be positive")
            except:
                is_valid = False
                warnings.append("Invalid load magnitude")
        
        # Check load factors for time dependent loads
        if hasattr(obj, 'IsTimeDependent') and obj.IsTimeDependent:
            if not hasattr(obj, 'Duration') or obj.Duration <= 0:
                warnings.append("Time dependent load requires positive duration")
        
        obj.IsValid = is_valid
        
        if warnings:
            App.Console.PrintWarning(f"Load {obj.Label} warnings: {'; '.join(warnings)}\n")
    
    def get_equivalent_nodal_loads(self, obj, target_nodes: List) -> Dict:
        """
        Calculate equivalent nodal loads for finite element analysis.
        
        Args:
            obj: The DocumentObject
            target_nodes: List of nodes to distribute loads to
            
        Returns:
            Dictionary of nodal loads
        """
        nodal_loads = {}
        
        if not obj.IsValid or obj.TotalLoad == 0:
            return nodal_loads
        
        try:
            total_load = obj.TotalLoad
            direction = self._get_direction_vector(obj)
            
            # Simple distribution - divide total load among nodes
            load_per_node = total_load / len(target_nodes) if target_nodes else 0
            
            for node in target_nodes:
                if hasattr(node, 'Name'):
                    nodal_loads[node.Name] = {
                        'Fx': direction.x * load_per_node,
                        'Fy': direction.y * load_per_node,
                        'Fz': direction.z * load_per_node
                    }
            
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating nodal loads: {e}\n")
        
        return nodal_loads
    
    def calculateEffectivePressure(self, obj, face_normal: App.Vector) -> float:
        """
        Calculate effective pressure using dot product between load direction and face normal.
        
        Args:
            obj: The DocumentObject
            face_normal: Normal vector of the face
            
        Returns:
            Effective pressure value considering the angle between load direction and face normal
        """
        try:
            # Get load direction vector
            load_direction = self._getLoadDirection(obj)
            
            # Normalize vectors
            load_direction = self._normalizeVector(load_direction)
            face_normal = self._normalizeVector(face_normal)
            
            # Calculate dot product between load direction and face normal
            # This gives us the effective pressure considering the angle
            dot_product = (load_direction.x * face_normal.x + 
                          load_direction.y * face_normal.y + 
                          load_direction.z * face_normal.z)
            
            # Get base pressure magnitude
            pressure_magnitude = self._getPressureMagnitude(obj)
            
            # Calculate effective pressure
            # Take absolute value to ensure positive pressure for magnitude
            effective_pressure = pressure_magnitude * abs(dot_product)
            
            return effective_pressure
            
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating effective pressure: {e}\n")
            return 0.0
    
    def _get_direction_vector(self, obj) -> App.Vector:
        """Get load direction vector from object properties."""
        # Default downward direction
        direction = App.Vector(0, 0, -1)
        
        # Check for LoadDirection property (preferred)
        if hasattr(obj, 'LoadDirection'):
            direction = obj.LoadDirection
        # Fallback to Direction property
        elif hasattr(obj, 'Direction'):
            direction_map = {
                "+X Global": App.Vector(1, 0, 0),
                "-X Global": App.Vector(-1, 0, 0),
                "+Y Global": App.Vector(0, 1, 0),
                "-Y Global": App.Vector(0, -1, 0),
                "+Z Global": App.Vector(0, 0, 1),
                "-Z Global": App.Vector(0, 0, -1),
                "Normal": App.Vector(0, 0, -1)  # Default normal
            }
            if obj.Direction in direction_map:
                direction = direction_map[obj.Direction]
            elif obj.Direction == "Custom" and hasattr(obj, 'CustomDirection'):
                direction = obj.CustomDirection
                
        # Normalize the direction vector
        return ensure_property_exists

import math
import numpy as np

class ViewProviderAreaLoad:

        Create a helper function to safely add properties with error handling.
        
        Args:
            obj: The DocumentObject to add properties to
            
        Returns:
            A function that can be used to add properties to the object
        """
        def ensure_property_exists(prop_type, prop_name, prop_group, prop_doc, default=None):
            try:
                if not hasattr(obj, prop_name):
                    obj.addProperty(prop_type, prop_name, prop_group, prop_doc)
                    if default is not None:
                        setattr(obj, prop_name, default)
                return True
            except Exception as e:
                App.Console.PrintWarning(f"Error creating property {prop_name}: {e}\n")
                return False
        return ensure_property_exists

def _normalizeDirection(self, direction: App.Vector) -> App.Vector:
    """
    Normalize a direction vector.
    
    Args:
        direction: Direction vector to normalize
        
    Returns:
        Normalized direction vector
    """
    length = math.sqrt(direction.x**2 + direction.y**2 + direction.z**2)
    if length > 0:
        direction = App.Vector(direction.x/length, direction.y/length, direction.z/length)
            
        return direction
    
    def _getPressureMagnitude(self, obj) -> float:
        """
        Get pressure magnitude from object properties.
        
        Args:
            obj: The DocumentObject
            
        Returns:
            Pressure magnitude value
        """
        # First try LoadIntensity property (preferred)
        if hasattr(obj, 'LoadIntensity'):
            try:
                return self.parseLoadIntensity(obj.LoadIntensity)
            except Exception as e:
                App.Console.PrintWarning(f"Could not parse LoadIntensity: {e}\n")
        
        # Fall back to Magnitude property
        if hasattr(obj, 'Magnitude'):
            try:
                return float(obj.Magnitude.getValueAs('N/mm^2'))
            except Exception:
                try:
                    return float(obj.Magnitude)
                except Exception:
                    pass
        
        return 0.0
    
    def _normalizeVector(self, vector: App.Vector) -> App.Vector:
        """
        Normalize a vector.
        
        Args:
            vector: Vector to normalize
            
        Returns:
            Normalized vector
        """
        length = math.sqrt(vector.x**2 + vector.y**2 + vector.z**2)
        if length > 0:
            return App.Vector(vector.x/length, vector.y/length, vector.z/length)
        return vector
    
    def mapCoordinateSystem(self, vector: App.Vector) -> App.Vector:
        """
        Map coordinate system from FreeCAD to solver (X→X, Y→Z, Z→Y).
        
        Args:
            vector: Vector in FreeCAD coordinate system
            
        Returns:
            Vector in solver coordinate system
        """
        # FreeCAD: X→Solver X, FreeCAD Y→Solver Z, FreeCAD Z→Solver Y
        return App.Vector(vector.x, vector.z, vector.y)
    
    def getEdgeDistributionFactors(self, obj, face, distribution_method: str = "TwoWay") -> List[float]:
        """
        Calculate edge distribution factors based on distribution method.
        
        Args:
            obj: The DocumentObject
            face: The face to calculate distribution for
            distribution_method: Distribution method ("OneWay", "TwoWay", "OpenStructure")
            
        Returns:
            List of edge distribution factors
        """
        # Default equal distribution
        edge_factors = [0.25, 0.25, 0.25, 0.25]
        
        try:
            if distribution_method == "OneWay":
                edge_factors = self._calculateOneWayEdgeFactors(obj, face)
            elif distribution_method == "TwoWay":
                edge_factors = self._calculateTwoWayEdgeFactors(obj, face)
            elif distribution_method == "OpenStructure":
                edge_factors = self._calculateOpenStructureEdgeFactors(obj, face)
                
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating edge distribution factors: {e}\n")
            
        return edge_factors
    
    def _calculateOneWayEdgeFactors(self, obj, face) -> List[float]:
        """
        Calculate edge distribution factors for one-way load distribution.
        
        Args:
            obj: The DocumentObject
            face: The face to calculate distribution for
            
        Returns:
            List of edge distribution factors
        """
        # Default equal distribution
        edge_factors = [0.0, 0.0, 0.0, 0.0]
        
        # Get one-way direction
        direction = App.Vector(1, 0, 0)  # Default X direction
        if hasattr(obj, 'OneWayDirection'):
            if obj.OneWayDirection == "X":
                direction = App.Vector(1, 0, 0)
            elif obj.OneWayDirection == "Y":
                direction = App.Vector(0, 1, 0)
            elif obj.OneWayDirection == "Custom" and hasattr(obj, 'CustomDistributionDirection'):
                direction = obj.CustomDistributionDirection
                
        # Normalize direction
        direction = self._normalizeVector(direction)
        
        try:
            # Find edges parallel and perpendicular to direction
            parallel_edges = []
            perpendicular_edges = []
            
            if hasattr(face, 'Edges'):
                for i, edge in enumerate(face.Edges[:4]):  # Use first 4 edges
                    if edge.Length > 0:
                        edge_dir = edge.Vertexes[1].Point - edge.Vertexes[0].Point
                        edge_length = math.sqrt(edge_dir.x**2 + edge_dir.y**2 + edge_dir.z**2)
                        if edge_length > 0:
                            edge_dir = self._normalizeVector(edge_dir)
                            # Check if edge is parallel to direction (using dot product)
                            edge_dot = abs(edge_dir.x * direction.x + 
                                         edge_dir.y * direction.y + 
                                         edge_dir.z * direction.z)
                            if edge_dot > 0.7:  # If dot product is close to 1, they're parallel
                                parallel_edges.append(i)
                            else:
                                perpendicular_edges.append(i)
                
                # For one-way distribution, load goes to perpendicular edges
                if len(perpendicular_edges) >= 2:
                    # Set perpendicular edges to 0.5 each (shared load)
                    for i in perpendicular_edges[:2]:  # Use first two perpendicular edges
                        if i < len(edge_factors):
                            edge_factors[i] = 0.5
            
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating one-way edge factors: {e}\n")
            
        return edge_factors
    
    def _calculateTwoWayEdgeFactors(self, obj, face) -> List[float]:
        """
        Calculate edge distribution factors for two-way load distribution.
        
        Args:
            obj: The DocumentObject
            face: The face to calculate distribution for
            
        Returns:
            List of edge distribution factors
        """
        # Default equal distribution to all edges
        edge_factors = [0.25, 0.25, 0.25, 0.25]
        
        try:
            if hasattr(face, 'Edges') and len(face.Edges) >= 4:
                # Get edge lengths
                edge_lengths = [edge.Length for edge in face.Edges[:4]]  # Use first 4 edges
                
                # Calculate edge factors based on relative lengths
                # For a rectangle, longer edges get more load (simplified calculation)
                total_length = sum(edge_lengths)
                
                if total_length > 0:
                    edge_factors = [length/total_length for length in edge_lengths]
                    
                    # Pad to 4 elements if needed
                    while len(edge_factors) < 4:
                        edge_factors.append(0.0)
                        
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating two-way edge factors: {e}\n")
            
        return edge_factors
    
    def _calculateOpenStructureEdgeFactors(self, obj, face) -> List[float]:
        """
        Calculate edge distribution factors for open structure load distribution.
        
        Args:
            obj: The DocumentObject
            face: The face to calculate distribution for
            
        Returns:
            List of edge distribution factors
        """
        # For open structure, load is distributed based on projected areas
        # This is a simplified implementation; real-world calculation would be more complex
        edge_factors = [0.25, 0.25, 0.25, 0.25]  # Default equal distribution
        
        try:
            # Get load direction
            load_direction = self._getLoadDirection(obj)
            load_direction = self._normalizeVector(load_direction)
            
            if hasattr(face, 'Edges') and len(face.Edges) >= 4:
                # Calculate edge factors based on projection and edge orientation
                factors = []
                for i, edge in enumerate(face.Edges[:4]):
                    if edge.Length > 0:
                        # Get edge direction
                        edge_dir = edge.Vertexes[1].Point - edge.Vertexes[0].Point
                        edge_dir = self._normalizeVector(edge_dir)
                        
                        # Get projection factor (dot product with load direction)
                        proj_factor = abs(edge_dir.x * load_direction.x + 
                                         edge_dir.y * load_direction.y + 
                                         edge_dir.z * load_direction.z)
                        
                        # Use projection factor to adjust edge factor
                        factors.append(proj_factor)
                    else:
                        factors.append(0.0)
                
                # Normalize edge factors to sum to 1.0
                factor_sum = sum(factors)
                if factor_sum > 0:
                    edge_factors = [factor / factor_sum for factor in factors]
                else:
                    # If all factors are zero, use equal distribution
                    edge_factors = [0.25, 0.25, 0.25, 0.25]
                    
        except Exception as e:
            App.Console.PrintWarning(f"Error calculating open structure edge factors: {e}\n")
            
        return edge_factors


class ViewProviderAreaLoad:
    """
    ViewProvider for AreaLoad with enhanced visualization.
    """
    
    def __init__(self, vobj):
        """Initialize ViewProvider."""
        vobj.Proxy = self
        self.Object = vobj.Object
        
        # Display properties
        vobj.addProperty("App::PropertyBool", "ShowLoadInfo", "Display",
                        "Show load information text")
        vobj.ShowLoadInfo = True
        
        vobj.addProperty("App::PropertyFloat", "TextSize", "Display",
                        "Text size for load information")
        vobj.TextSize = 12.0
    
    def getIcon(self) -> str:
        """Return icon for area load."""
        if not hasattr(self.Object, 'LoadCategory'):
            return self._get_icon_path("area_load_generic.svg")
        
        category = self.Object.LoadCategory
        icon_map = {
            "DL": "area_load_dead.svg",
            "LL": "area_load_live.svg",
            "W": "area_load_wind.svg",
            "E": "area_load_seismic.svg",
            "T": "area_load_thermal.svg"
        }
        
        icon_name = icon_map.get(category, "area_load_generic.svg")
        return self._get_icon_path(icon_name)
    
    def _get_icon_path(self, icon_name: str) -> str:
        """Get full path to icon file."""
        icon_dir = os.path.join(os.path.dirname(__file__), "..", "resources", "icons")
        return os.path.join(icon_dir, icon_name)
    
    def setEdit(self, vobj, mode: int) -> bool:
        """Open area load properties panel."""
        if mode == 0:
            try:
                from ..taskpanels.AreaLoadPanel import AreaLoadApplicationPanel
                self.panel = AreaLoadApplicationPanel(vobj.Object)
                Gui.Control.showDialog(self.panel)
                return True
            except ImportError:
                App.Console.PrintWarning("AreaLoadPanel not yet implemented\n")
                return False
        return False
    
    def unsetEdit(self, vobj, mode: int) -> bool:
        """Close area load editing panel."""
        if hasattr(self, 'panel'):
            Gui.Control.closeDialog()
        return True
    
    def doubleClicked(self, vobj) -> bool:
        """Handle double-click to open properties."""
        return self.setEdit(vobj, 0)
    
    def updateData(self, obj, prop: str) -> None:
        """Update visualization when object data changes."""
        if prop in ["TargetFaces", "Magnitude", "ShowLoadArrows"]:
            # Trigger visual update
            pass


def makeAreaLoad(target_faces=None, magnitude="5.0 kN/m^2", load_type="Dead Load (DL)", name="AreaLoad"):
    """
    Create a new AreaLoad object.
    
    Args:
        target_faces: List of faces to apply load to
        magnitude: Load magnitude
        load_type: Type of load
        name: Object name
        
    Returns:
        Created AreaLoad object
    """
    doc = App.ActiveDocument
    if not doc:
        App.Console.PrintError("No active document. Please create or open a document first.\n")
        return None
    
    # Create the object
    obj = doc.addObject("App::DocumentObjectGroupPython", name)
    AreaLoad(obj)
    
    # Create ViewProvider
    if App.GuiUp:
        ViewProviderAreaLoad(obj.ViewObject)
    
    # Set properties
    if target_faces:
        obj.TargetFaces = target_faces if isinstance(target_faces, list) else [target_faces]
    obj.Magnitude = magnitude
    obj.LoadType = load_type
    
    # Generate unique ID
    load_count = len([o for o in doc.Objects if hasattr(o, 'Proxy') and hasattr(o.Proxy, 'Type') and o.Proxy.Type == "AreaLoad"])
    obj.LoadID = f"AL{load_count + 1:03d}"
    
    # Recompute to update properties
    obj.recompute()
    doc.recompute()
    
    App.Console.PrintMessage(f"Created AreaLoad: {obj.Label} with ID: {obj.LoadID}\n")
    return obj